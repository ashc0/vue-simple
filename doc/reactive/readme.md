## 基础响应式

使用Proxy代理target，在get时触发依赖收集，set时触发依赖更新。

使用effect注册副作用函数，并声明一个全局的WeakMap。注册的副作用函数被放到全局，并调用，调用时一旦触发了Proxy的get，就代表这个副作用函数依赖于此响应式数据，于是触发依赖收集。

依赖收集 track：读取被挂载到全局的副作用函数，放入全局的WeakMap中，这个WeakMap的数据结构：
```ts
type DepsMap = WeakMap<target: object, Map<key: string, Set<function>>>
```

依赖更新 trigger：根据发生变动的target和key，获取到 EffectSet，遍历执行副作用函数。

## cleanup 分支切换

背景：在一个副作用函数中，如果有多个响应式数据，并且一部分响应式数据是存在于分支当中的，那么当分支不满足条件时，就需要把此分支下的响应式数据的此副作用函数清除掉。避免此副作用函数被错误的触发。

思路：触发一个副作用之前，先把此副作用函数从所有响应式数据的依赖集合中清除掉，为此需要记录下每个副作用函数所关联的响应式数据。然后执行副作用函数，执行期间会触发收集依赖。这样就能确认此副作用函数的依赖情况是最新的。

实现：改写effect函数，将副作用函数用一个新函数再包装一层来代替成为新的副作用函数，并且在这个新函数上挂载一个依赖列表，其中存放EffectSet。同时改写track，将EffectSet放入这个副作用函数的以来列表中。新函数的内容是先清除依赖，再执行副作用函数，并在执行期间收集依赖。最后，改写trigger，cleanup其实就是先删除再添加，这样会造成无限循环，于是创造一个effectSet的副本，遍历这个副本，这样哪怕cleanup改变了原始的effectSet也不会对副本造成影响。

清除依赖 cleanup：遍历包装函数的依赖列表，每一项都是副作用函数依赖的每个响应式数据的依赖集合，从集合中删除此包装函数。最后清空依赖列表。